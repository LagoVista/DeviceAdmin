<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Device_BatteryLevel" xml:space="preserve">
    <value>Battery Level</value>
  </data>
  <data name="Device_Capabilities" xml:space="preserve">
    <value>Capabilities</value>
  </data>
  <data name="Common_CreatedBy" xml:space="preserve">
    <value>Created By</value>
  </data>
  <data name="Common_CreationDate" xml:space="preserve">
    <value>Creation Date</value>
  </data>
  <data name="Device_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="Device_DeviceId" xml:space="preserve">
    <value>Device Id</value>
  </data>
  <data name="Device_DeviceNotes" xml:space="preserve">
    <value>Notes</value>
  </data>
  <data name="Device_FirmwareVersion" xml:space="preserve">
    <value>Firmware Version</value>
  </data>
  <data name="Device_GeoLocation" xml:space="preserve">
    <value>Geo Location</value>
  </data>
  <data name="Common_UniqueId" xml:space="preserve">
    <value>System Id</value>
  </data>
  <data name="Device_IsBatteryPowered" xml:space="preserve">
    <value>Battery Powered</value>
  </data>
  <data name="Common_LastUpdated" xml:space="preserve">
    <value>Last Updated</value>
  </data>
  <data name="Common_LastUpdatedBy" xml:space="preserve">
    <value>Last Updated By</value>
  </data>
  <data name="Device_Location" xml:space="preserve">
    <value>Location</value>
  </data>
  <data name="DeviceType_Manufacturer" xml:space="preserve">
    <value>Manufacturer</value>
  </data>
  <data name="DeviceType_ModelNumber" xml:space="preserve">
    <value>Model Number</value>
  </data>
  <data name="Device_SerialNumber" xml:space="preserve">
    <value>Serial Number</value>
  </data>
  <data name="Device_DeviceId_Help" xml:space="preserve">
    <value>Your device id is a set of alpha numeric characters that will uniquely identify the device across your organization.</value>
  </data>
  <data name="Device_DeviceId_Required" xml:space="preserve">
    <value>Device Id is a required field and must be unique.</value>
  </data>
  <data name="Gateway_Address" xml:space="preserve">
    <value>Address</value>
  </data>
  <data name="Gateway_Address_Help" xml:space="preserve">
    <value>Enter either a DNS name or a IP Address</value>
  </data>
  <data name="Gateway_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="Gateway_Device_Id" xml:space="preserve">
    <value>Device Id</value>
  </data>
  <data name="Gateway_GeoLocation" xml:space="preserve">
    <value>Geo Location</value>
  </data>
  <data name="Gateway_Location" xml:space="preserve">
    <value>Location</value>
  </data>
  <data name="Gateway_Manufacturer" xml:space="preserve">
    <value>Manufacturer</value>
  </data>
  <data name="Gateway_ModelNumber" xml:space="preserve">
    <value>Model Number</value>
  </data>
  <data name="Gateway_Name" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="Gateway_Notes" xml:space="preserve">
    <value>Notes</value>
  </data>
  <data name="Gateway_SerialNumber" xml:space="preserve">
    <value>Serial Number</value>
  </data>
  <data name="Gatway_Firmware_Version" xml:space="preserve">
    <value>Firmware Version</value>
  </data>
  <data name="Device_LastContact" xml:space="preserve">
    <value>Last Contact</value>
  </data>
  <data name="Device_Online" xml:space="preserve">
    <value>Online</value>
  </data>
  <data name="Device_Status" xml:space="preserve">
    <value>Status</value>
  </data>
  <data name="Device_DeviceType" xml:space="preserve">
    <value>Device Type</value>
  </data>
  <data name="Device_GatewayDevice" xml:space="preserve">
    <value>Gateway </value>
  </data>
  <data name="Device_ConnectionStatus" xml:space="preserve">
    <value>Connection Status</value>
  </data>
  <data name="Device_Account" xml:space="preserve">
    <value>Account</value>
  </data>
  <data name="Device_CustomFields" xml:space="preserve">
    <value>Custom Fields</value>
  </data>
  <data name="Gateway_Account" xml:space="preserve">
    <value>Account</value>
  </data>
  <data name="Gateway_CustomFields" xml:space="preserve">
    <value>Custom Fields</value>
  </data>
  <data name="DeviceWorkflow_CustomFields" xml:space="preserve">
    <value>Custom Fields</value>
  </data>
  <data name="DeviceWorkflow_ConfigVersion" xml:space="preserve">
    <value>Configuration Version</value>
  </data>
  <data name="Common_Name" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="Common_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="Common_Key" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="Common_Key_Help" xml:space="preserve">
    <value>The key is used to identify this item in scripts and must be unique with respect to it's parent. One a key has been assigned, it can not be changed.</value>
  </data>
  <data name="Common_Key_Validation" xml:space="preserve">
    <value>The key must 1) begin with a lower case letter, 2) contain only lower case letters and numbers, and 3) must be between 3 and 50 characters.</value>
  </data>
  <data name="Unit_Definitions" xml:space="preserve">
    <value>Unit Definitions</value>
  </data>
  <data name="UnitSet_Help" xml:space="preserve">
    <value>A single value can be associated with multiple units. Take temperature as an example; it can be measured in Celsius or Fahrenheit, and these attributes can be incorporated here. Each unit is part of a Unit Set, and values are stored with a default unit that allows for conversion between different units using the default setting.</value>
  </data>
  <data name="Unit_Abbreviation" xml:space="preserve">
    <value>Abbreviation</value>
  </data>
  <data name="Unit_ConversionTo_Script" xml:space="preserve">
    <value>Script - Convert to Default to this Unit</value>
  </data>
  <data name="Unit_ConversionTo_Script_Help" xml:space="preserve">
    <value>Provide a script with a formulat  that will convert a default unit value to this unit.</value>
  </data>
  <data name="Unit_IsDefault" xml:space="preserve">
    <value>Default Units</value>
  </data>
  <data name="Unit_NumberDecimal" xml:space="preserve">
    <value>Number Decimal Points</value>
  </data>
  <data name="Common_IsPublic" xml:space="preserve">
    <value>Is Public</value>
  </data>
  <data name="CustomField_FieldType" xml:space="preserve">
    <value>Field Type</value>
  </data>
  <data name="CustomField_FieldType_Bool" xml:space="preserve">
    <value>True/False</value>
  </data>
  <data name="CustomField_FieldType_Date" xml:space="preserve">
    <value>Date</value>
  </data>
  <data name="CustomField_FIeldType_DateTime" xml:space="preserve">
    <value>Date Time</value>
  </data>
  <data name="CustomField_FieldType_Decimal" xml:space="preserve">
    <value>Decimal</value>
  </data>
  <data name="CustomField_FieldType_Integer" xml:space="preserve">
    <value>Integer</value>
  </data>
  <data name="CustomField_FieldType_IPAddress" xml:space="preserve">
    <value>IP Address</value>
  </data>
  <data name="CustomField_FieldType_String" xml:space="preserve">
    <value>Text</value>
  </data>
  <data name="CustomField_FieldType_Time" xml:space="preserve">
    <value>Time</value>
  </data>
  <data name="CustomField_FieldType_WebSite" xml:space="preserve">
    <value>Web Site</value>
  </data>
  <data name="CustomField_IsRequired" xml:space="preserve">
    <value>Is Required</value>
  </data>
  <data name="CustomField_Label" xml:space="preserve">
    <value>Label</value>
  </data>
  <data name="CustomField_RegEx" xml:space="preserve">
    <value>Validation RegEx</value>
  </data>
  <data name="CustomField_RegEx_Help" xml:space="preserve">
    <value>If your field type is a string, you can add a custom validation regular expression to ensure the data that is captured is in the correct format.</value>
  </data>
  <data name="StateMachine" xml:space="preserve">
    <value>State Machine</value>
  </data>
  <data name="Action_AssociatedAttribute" xml:space="preserve">
    <value>Associated Attribute</value>
  </data>
  <data name="Action_AssociatedAttribute_Help" xml:space="preserve">
    <value>The associated attribute will be the default attribute for this action.</value>
  </data>
  <data name="Action_ExecuteFromGet" xml:space="preserve">
    <value>Execute this Script from REST Get</value>
  </data>
  <data name="Action_ExecuteFromGet_Help" xml:space="preserve">
    <value>This action will be executed from a REST Get service call with the attribute in the query string for the device id or device group.</value>
  </data>
  <data name="Action_ExecuteFromPost" xml:space="preserve">
    <value>Execute this Script from REST Post</value>
  </data>
  <data name="Action_ExecuteFromPost_Help" xml:space="preserve">
    <value>This action will be executed from a web service call for the device or device group in the form of a REST Post with fom post values as described in the actions attributes</value>
  </data>
  <data name="Action_ExecuteFromScript" xml:space="preserve">
    <value>Execute from Script</value>
  </data>
  <data name="Action_ExecuteFromScript_Help" xml:space="preserve">
    <value>This action can be executed by another action or a script associated with the device configuration</value>
  </data>
  <data name="Parameters" xml:space="preserve">
    <value>Parameters</value>
  </data>
  <data name="Parameter_Types_TrueFalse" xml:space="preserve">
    <value>True/False</value>
  </data>
  <data name="Parameter_Types" xml:space="preserve">
    <value>Parameter Types</value>
  </data>
  <data name="Parameter_Types_Decimal" xml:space="preserve">
    <value>Decimal</value>
  </data>
  <data name="Parameter_Types_Integer" xml:space="preserve">
    <value>Integer</value>
  </data>
  <data name="Parameter_Types_String" xml:space="preserve">
    <value>String</value>
  </data>
  <data name="Action_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="Action_NodeRedFlows" xml:space="preserve">
    <value>Node Red Flows</value>
  </data>
  <data name="Action_RemoteUri" xml:space="preserve">
    <value>Remote URI</value>
  </data>
  <data name="Common_IsRequired" xml:space="preserve">
    <value>Is Required</value>
  </data>
  <data name="Parameter_Type" xml:space="preserve">
    <value>Parameter Type</value>
  </data>
  <data name="Actoin_Parameter_Key_Help" xml:space="preserve">
    <value>This key will be used as the parameter name for the form post or query string attribute.  The key must be lower case and contain only letters and numbers, it should also start with a letter, not a number.</value>
  </data>
  <data name="Action_ExecuteFromStateMachine" xml:space="preserve">
    <value>Execute From State Machine</value>
  </data>
  <data name="Action_ExecuteFromstateMachine_Help" xml:space="preserve">
    <value>You can use this action to be executed when your state machine transitions between states.</value>
  </data>
  <data name="Attribute_SharedAttribute_Help" xml:space="preserve">
    <value>You can configure your attribute to be a Shared Attribute.  Some attributes such as temperature, speed, battery level, direction may be common accross your devices.  A Shared Attribute is easy to add and promotes re-use across devices.</value>
  </data>
  <data name="Attribute_Type_State_Help" xml:space="preserve">
    <value>You can configure your attribute to be a collection of states.  If you do so you can describe the different states that your attribute can be in at any one time.  States are fixed set of conditions such as On/Off, Running/Idle/Error.  You will need to define all the states here that your attribute can be in at any one time.</value>
  </data>
  <data name="Common_Note" xml:space="preserve">
    <value>Note</value>
  </data>
  <data name="Common_Notes" xml:space="preserve">
    <value>Notes</value>
  </data>
  <data name="Attribute_Type_Discrete" xml:space="preserve">
    <value>Discrete Value</value>
  </data>
  <data name="Attribute_Shared" xml:space="preserve">
    <value>Shared</value>
  </data>
  <data name="Attribute_Type_States" xml:space="preserve">
    <value>States</value>
  </data>
  <data name="CustomField_FieldType_Email" xml:space="preserve">
    <value>Email</value>
  </data>
  <data name="CustomField_FieldType_Key" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="CustomField_FieldType_Password" xml:space="preserve">
    <value>Password</value>
  </data>
  <data name="Attribute_Direction" xml:space="preserve">
    <value>Direction</value>
  </data>
  <data name="Attribute_Direction_Input" xml:space="preserve">
    <value>Input</value>
  </data>
  <data name="Attribute_Direction_InputAndOutput" xml:space="preserve">
    <value>Input and Output</value>
  </data>
  <data name="Attribute_Direction_Output" xml:space="preserve">
    <value>Output</value>
  </data>
  <data name="DeviceWorkflow_Environment_Development" xml:space="preserve">
    <value>Development</value>
  </data>
  <data name="DeviceWorkflow_Environment" xml:space="preserve">
    <value>Environments are used to maintain different device configurations that can be updated and tested without impacting production.  Also once an environment is migrated into Production it can be rolled back to Staging if issues are found.</value>
  </data>
  <data name="DeviceWorkflow_Environment_Development_Help" xml:space="preserve">
    <value>The Development Environment should be used to make changes to a device workflow where it won't impact any devices that are used in a production capacity.  Once development or updates have been completed in this environment, those changes are published to the Staging environment so they can be tested.</value>
  </data>
  <data name="DeviceWorkflow_Environment_Production" xml:space="preserve">
    <value>Production</value>
  </data>
  <data name="DeviceWorkflow_Environment_Production_Help" xml:space="preserve">
    <value>The Production Environment is the default workflow for a device to be in.  Once it has been developed and tested, the device configuration will be moved in to production.</value>
  </data>
  <data name="DeviceWorkflow_Environment_Staging" xml:space="preserve">
    <value>Staging</value>
  </data>
  <data name="DeviceWorkflow_Environment_Staging_Help" xml:space="preserve">
    <value>Once a new device workflow has been created or updated in the Development Environment and Tested in the Testing Environemnt, it will be moved to the Staging Environment where it be then be swapped into the Production Environment.  If issues are found once the new device configuration goes live the previous production configuration can be restored.</value>
  </data>
  <data name="Attribute_Direction_Help" xml:space="preserve">
    <value>An attribute can be an Input which can only be set, it can be an Output which is Read Only or it can be and Input and an Output which can both be read and updated.</value>
  </data>
  <data name="DeviceWorkflow_InputCommands" xml:space="preserve">
    <value>Input Commands</value>
  </data>
  <data name="DeviceWorkflow_InputCommands_Help" xml:space="preserve">
    <value>Input Commands can perform functionality on a Device to manipulate it's real world attribute or states.</value>
  </data>
  <data name="DeviceWorkflow_Attributes" xml:space="preserve">
    <value>Attributes</value>
  </data>
  <data name="DeviceWorkflow_Attributes_Help" xml:space="preserve">
    <value>Attributes act as metadata linked to a device workflow, contributing to the preservation of the device's state. These attributes are represented as simple values with an optional unit. Stored on a per-device basis, they are accessible to all workflows associated with the device.</value>
  </data>
  <data name="Action_Shared" xml:space="preserve">
    <value>Shared Action</value>
  </data>
  <data name="Action_Standard_Help" xml:space="preserve">
    <value>A Shared Action is one that is predefined and can be attached to a device configuration.  A Shared Action can be used so that implements a specific Shared Action can participate in a Device Group.</value>
  </data>
  <data name="StateMachine_InitialState" xml:space="preserve">
    <value>Initial State</value>
  </data>
  <data name="StateMachine_InitialState_Help" xml:space="preserve">
    <value>The Initial State will be the State that the State Machine will be in when the State Machine is first created. </value>
  </data>
  <data name="StateMachine_State" xml:space="preserve">
    <value>State</value>
  </data>
  <data name="StateMachine_State_Action" xml:space="preserve">
    <value>Action</value>
  </data>
  <data name="StateMachine_Transitions" xml:space="preserve">
    <value>Transitions</value>
  </data>
  <data name="StateMachine_Transition_Action" xml:space="preserve">
    <value>Transition Actions</value>
  </data>
  <data name="StateMachine_Transition_State" xml:space="preserve">
    <value>New State</value>
  </data>
  <data name="StateMachine_Event" xml:space="preserve">
    <value>Event</value>
  </data>
  <data name="StateMachine_State_TransitionInAction" xml:space="preserve">
    <value>Transition In Action</value>
  </data>
  <data name="StateMachine_State_TransitionInAction_Help" xml:space="preserve">
    <value>This is an action that should take place when an event occurs that will transition the state machine into this state</value>
  </data>
  <data name="StateMachine_States" xml:space="preserve">
    <value>States</value>
  </data>
  <data name="StateMachines" xml:space="preserve">
    <value>State Machines</value>
  </data>
  <data name="CustomFields_DefaultValue" xml:space="preserve">
    <value>Default Value</value>
  </data>
  <data name="CustomFields_DefaultValue_Help" xml:space="preserve">
    <value>When an object is created that uses this default value it can optionally be inintialized with this default value.</value>
  </data>
  <data name="StateMachine_Exception_OnInvalidEvent" xml:space="preserve">
    <value>Exception on Missing Event</value>
  </data>
  <data name="StateMachine_Exception_OnInvalidEvent_Help" xml:space="preserve">
    <value>Your State Machine can be configured so that if an event arrives and the current state does not have a hanlder for that event, it will send an exception message.</value>
  </data>
  <data name="StateMachine_Initialization_Actions" xml:space="preserve">
    <value>Initialization Actions</value>
  </data>
  <data name="StateMachine_Initialization_Actions_Help" xml:space="preserve">
    <value>As set of actions and be defined when the state machine is created to perform any actions or initialize any variables.  The actions are guarenteed to be execute in the order they are listed and each action will finish executing prior to the next action being started.</value>
  </data>
  <data name="StateMachine_NewState" xml:space="preserve">
    <value>New State</value>
  </data>
  <data name="StateMachine_NewState_Help" xml:space="preserve">
    <value>When this transition occurs, the New State will be the state that the State Machine will currently be in.  It is possible that the the transition may leave the State Machine in the current state, if that's the case, the Transition is used to simply exectue an action.</value>
  </data>
  <data name="StateMachine_Transition_Action_Help" xml:space="preserve">
    <value>As the event triggers a transition between different states a set of actions can be execute.  The actions are guarenteed to be execute in the order they are listed and each action will finish executing prior to the next action being started.</value>
  </data>
  <data name="StateMachine_Transition_EventHelp" xml:space="preserve">
    <value>This is the event that can be handled by the current state in which this transition is defined.  Each current state must have unique events defined that can be handled and it is not required for all states to handle all events.  The state machine can be configured to send an error message if an event comes in while the state machine can not handle the event.</value>
  </data>
  <data name="StateMachine_Variables" xml:space="preserve">
    <value>Variables</value>
  </data>
  <data name="StateMachine_Variables_Help" xml:space="preserve">
    <value>A set of simple variables can be defined that will be availble through out the life time of your state machine.  These variables will be available to custom scripts or a REST Get action.   These variables should be considered Public Read and and Private Write.  That is to say that they can only be modified via actions triggered within the state machine or state machine initialization.</value>
  </data>
  <data name="StateMachine_Title" xml:space="preserve">
    <value>State Machine</value>
  </data>
  <data name="StateTransition_Description" xml:space="preserve">
    <value>A State Transition can be added to a State.  A Transition is a Definition of an Event that can be handled, an Action to be Executed and a New State that the State Machine will be in after the event is handled.  Note that it is possible that the state may remain the same and the event will be used to only execute an action.</value>
  </data>
  <data name="StateTransition_UserHelp" xml:space="preserve">
    <value>A State Transition can be added to a State.  A Transition is a Definition of an Event that can be handled, an Action to be Executed and a New State that the State Machine will be in after the event is handled.  Note that it is possible that the state may remain the same and the event will be used to only execute an action.</value>
  </data>
  <data name="ActionParameter_Description" xml:space="preserve">
    <value>An Action Parameter are parameter that can be passed to an action.  They can be passed in as a arguement to a script, as a KVP form value in a rest form POST, or in the query string of a rest GET method.</value>
  </data>
  <data name="ActionParameter_Help" xml:space="preserve">
    <value>An Action Parameter are parameter that can be passed to an action.  They can be passed in as a arguement to a script, as a KVP form value in a rest form POST, or in the query string of a rest GET method.</value>
  </data>
  <data name="ActionParameter_Title" xml:space="preserve">
    <value>Action Parameter</value>
  </data>
  <data name="Action_Description" xml:space="preserve">
    <value>Actions can perform functionality on a Device to manipulate it's real world or attribute states</value>
  </data>
  <data name="Action_Help" xml:space="preserve">
    <value>Actions can perform functionality on a Device to manipulate it's real world or attribute states</value>
  </data>
  <data name="Action_Title" xml:space="preserve">
    <value>Action</value>
  </data>
  <data name="AdminNote_Description" xml:space="preserve">
    <value>Notes are free form text that can be attached to many different types of entities.</value>
  </data>
  <data name="AdminNote_Help" xml:space="preserve">
    <value>Notes are free form text that can be attached to many different types of entities.</value>
  </data>
  <data name="AdminNote_Title" xml:space="preserve">
    <value>Admin Note</value>
  </data>
  <data name="UnitSet_Description" xml:space="preserve">
    <value>A single value can be associated with multiple units. Take temperature as an example; it can be measured in Celsius or Fahrenheit, and these attributes can be incorporated here. Each unit is part of a Unit Set, and values are stored with a default unit that allows for conversion between different units using the default setting.</value>
  </data>
  <data name="UnitSet_Title" xml:space="preserve">
    <value>Unit Set</value>
  </data>
  <data name="Attribute_Description" xml:space="preserve">
    <value>Attributes are used to store data associated with your devices.  This data generally comes from the sensor inputs, but can also come from other external actions that are applied to your device.  Attributes are used for reporting, can be used for state machines and can also be used in prepared commands to be sent to your device.</value>
  </data>
  <data name="Attribute_Help" xml:space="preserve">
    <value>The attributes you create will be used to store data for your device, this data can come from a sensor, an external action or the business logic associated with device.  Attributes reflect the most current data however you can configure your attribute to store historical data.  Attribute may also have units or can have a finite set of states.</value>
  </data>
  <data name="Attribute_Title" xml:space="preserve">
    <value>Attribute</value>
  </data>
  <data name="CustomFieldCollection_Description" xml:space="preserve">
    <value>The Custom Field Collection is a collection of custom fields that can be used across different device configurations to promote reuse</value>
  </data>
  <data name="CustomFieldCollection_Help" xml:space="preserve">
    <value>The Custom Field Collection is a collection of custom fields that can be used across different device configurations to promote reuse</value>
  </data>
  <data name="CustomFieldCollection_Title" xml:space="preserve">
    <value>Custom Field Collection</value>
  </data>
  <data name="CustomField_Description" xml:space="preserve">
    <value>Custom Fields can be used to extend Device Configuration.  It's not possible to know in advance what paramters each installation will require so these custom parameters can be defined when creating the device configration.  Then when a device is provisioned with the device configuration, those custom values can be populated.  Once they are added, they are first-class-citizens to be used in reports and scripts.</value>
  </data>
  <data name="CustomFIeld_Help" xml:space="preserve">
    <value>Custom Fields can be used to extend Device Configuration.  It's not possible to know in advance what paramters each installation will require so these custom parameters can be defined when creating the device configration.  Then when a device is provisioned with the device configuration, those custom values can be populated.  Once they are added, they are first-class-citizens to be used in reports and scripts.</value>
  </data>
  <data name="CustomField_Title" xml:space="preserve">
    <value>Custom Field</value>
  </data>
  <data name="DeviceConfiguration_Description" xml:space="preserve">
    <value>A device configuration is a collection of listeners, input translators, device configurations and senders.</value>
  </data>
  <data name="DeviceConfiguration_Help" xml:space="preserve">
    <value>A Device Configuration can be thought of as a template for provisioning devices.  It defines the Meta-Data, Actions and Attributes that need to be effectively managed when provisioning thousand or even millions of devices</value>
  </data>
  <data name="DeviceConfiguration_Title" xml:space="preserve">
    <value>Device Configuration</value>
  </data>
  <data name="NodeRedFlow_Description" xml:space="preserve">
    <value>A Node Red Flow can be configured as part of an action to perform more complicated work flows and steps.</value>
  </data>
  <data name="NodeRedFlow_Help" xml:space="preserve">
    <value>A Node Red Flow can be configured as part of an action to perform more complicated work flows and steps.</value>
  </data>
  <data name="NodeRedFlow_Title" xml:space="preserve">
    <value>Node Red Flow</value>
  </data>
  <data name="StateMachineEvent_Description" xml:space="preserve">
    <value>An Event is something that can be applied to a StateMachine as the event is applied it will determine the current state and then optionally perform an action and transition to a new state if the current state is configured to handle this event.</value>
  </data>
  <data name="StateMachineEvent_Title" xml:space="preserve">
    <value>State Machine Event</value>
  </data>
  <data name="StateMachineEvent_UserHelp" xml:space="preserve">
    <value>An Event is something that can be applied to a StateMachine as the event is applied it will determine the current state and then optionally perform an action and transition to a new state if the current state is configured to handle this event.</value>
  </data>
  <data name="StateMachine_Description" xml:space="preserve">
    <value>A State Machine is a mechanism that allows for complex work flows to be created base on know the current state, an event that is applied, the new state when the event is applied as well as any actions that should take place on that transitions.</value>
  </data>
  <data name="StateMachine_UserHelp" xml:space="preserve">
    <value>A State Machine is a mechanism that allows for complex work flows to be created base on know the current state, an event that is applied, the new state when the event is applied as well as any actions that should take place on that transitions.</value>
  </data>
  <data name="StateTransition_Title" xml:space="preserve">
    <value>State Transition</value>
  </data>
  <data name="State_Description" xml:space="preserve">
    <value>A State is a conceptual entity that a Device Configuration, Attribute or other mechanism can be in.  The state machine can only be in exactly one state at a given time, an action is used to transition the state into another state and optionally perform an action at that time.</value>
  </data>
  <data name="State_Title" xml:space="preserve">
    <value>State</value>
  </data>
  <data name="State_UserHelp" xml:space="preserve">
    <value>A State is a conceptual entity that a Device Configuration, Attribute or other mechanism can be in.  The state machine can only be in exactly one state at a given time, an action is used to transition the state into another state and optionally perform an action at that time.</value>
  </data>
  <data name="Unit_Description" xml:space="preserve">
    <value>An value can have many units.  For example, if the value is temperature, it can be expressed in Celcius or Farenheight, those attributes can be added here.  An Attribute Unit belongs to a Unit Set, attributes are stored with a default value in an attribute set and can be converted between different units via the default units.</value>
  </data>
  <data name="Unit_Help" xml:space="preserve">
    <value>An value can have many units.  For example, if the value is temperature, it can be expressed in Celcius or Farenheight, those attributes can be added here.  An Attribute Unit belongs to a Unit Set, attributes are stored with a default value in an attribute set and can be converted between different units via the default units.</value>
  </data>
  <data name="Unit_Title" xml:space="preserve">
    <value>Unit</value>
  </data>
  <data name="StateMachine_State_Transitions_Help" xml:space="preserve">
    <value />
  </data>
  <data name="StateMachine_Events" xml:space="preserve">
    <value>Events</value>
  </data>
  <data name="StateMachine_Events_Help" xml:space="preserve">
    <value>A state machines transitions and actions are triggered by events.  These are the events that are assocaited with this state machine.</value>
  </data>
  <data name="StateMachine_State_Transitions" xml:space="preserve">
    <value>Transitions</value>
  </data>
  <data name="StateMachine_State_DiagramX" xml:space="preserve">
    <value>Diagram X is the location on the state machine diagram where this state should be displayed</value>
  </data>
  <data name="StateMachine_State_DiagramY" xml:space="preserve">
    <value>Diagram Y is the location on the state machine diagram where this state should be displayed</value>
  </data>
  <data name="Environment" xml:space="preserve">
    <value>Environment</value>
    <comment>You can configure different environments so you can test your configurations prior to putting them into production</comment>
  </data>
  <data name="Environments" xml:space="preserve">
    <value>Environments</value>
    <comment>You can configure different environments so you can test your configurations prior to putting them into production</comment>
  </data>
  <data name="Environment_Dev" xml:space="preserve">
    <value>Development</value>
  </data>
  <data name="Environment_Help" xml:space="preserve">
    <value>You can configure different environments so you can test your configurations prior to putting them into production</value>
  </data>
  <data name="Environment_Production" xml:space="preserve">
    <value>Production</value>
  </data>
  <data name="Environment_Test" xml:space="preserve">
    <value>Test</value>
  </data>
  <data name="Attribute_SetScript" xml:space="preserve">
    <value>On Set Script</value>
  </data>
  <data name="Attribute_SetScript_Help" xml:space="preserve">
    <value>You can modify the Set Script to run an action when this value is being set.  You will have the old value, new value and where this attribute is getting set from available to use in your script.</value>
  </data>
  <data name="Attribute_AttributeType" xml:space="preserve">
    <value>Attribute Type</value>
  </data>
  <data name="Attribute_AttributeType_Help" xml:space="preserve">
    <value>The Attribute Type is employed to specify the kind of value that will be stored. It can be a discrete value, such as a number for a measurement, or it can be a state set. A straightforward example of a state set is an On/Off switch, which can have one of two states: On or Off.</value>
  </data>
  <data name="Attribute_Type_Discrete_Help" xml:space="preserve">
    <value>A discrete value is a numeric value that qunatifies something.  This could be something like a temperature, speed. RPM.</value>
  </data>
  <data name="OutputCommand_Title" xml:space="preserve">
    <value>Output Command</value>
  </data>
  <data name="Attribute_AttributeType_Select" xml:space="preserve">
    <value>-select attribute type-</value>
  </data>
  <data name="OutputCommand_Description" xml:space="preserve">
    <value>Output Commands are used to specify data that comes from your work flow or other device attributes that should be sent back to the device or to another system.  After you create your output command you will need to add it via the route for the device configuration to send the message.</value>
  </data>
  <data name="OutputCommand_Help" xml:space="preserve">
    <value>You can create a output command to send a message to your device.  In your device command you prepare the data from the available data on the device configuration.</value>
  </data>
  <data name="WorkflowInput_Description" xml:space="preserve">
    <value>Inputs are the entry point of data coming from your device.  Inputs can be as simple as an on/off switch, a thermostat or as complex as a GPS that sends in latitude and longitude.  Your sensor can also be virtual in that they provide an end point for your physical device to send additional data.  The Sensor is just the entry point and will eventually pass its data to an attribute for permanent storage.</value>
  </data>
  <data name="WorkflowInput_Help" xml:space="preserve">
    <value>You should start by creating input that match the physical sensors on your device.  These would be like an on/off contact switch or maybe a motion detector.  Once you add your sensor you need to specify the type of data that it will receive. The most common type of data would be discrete values such as a temperature, RPM or speed.  It could also be a more complex set of data such as a latitude or longitude.  In some cases your sensor will have certain conditions it can be in, we call these states.  You can identify those states here.</value>
  </data>
  <data name="WorkflowInput_Title" xml:space="preserve">
    <value>Input</value>
  </data>
  <data name="WorkflowInput_Type" xml:space="preserve">
    <value>Input Type</value>
  </data>
  <data name="WorkflowInput_Type_Description" xml:space="preserve">
    <value>The Input Type defines the type of data you expect to receive from your sensor. Typically this would be a simple value such as a temperature or speed, but also can have more complex data such as a latitude or longitude. A sensor might also be used to monitor certain conditions such as on/off or motion/no motions. We call these states. </value>
  </data>
  <data name="WorkflowInput_Type_Help" xml:space="preserve">
    <value>The Input Type defines the type of data you expect to receive from your input. Typically this would be a simple value such as a temperature or speed, but also can have more complex data such as a latitude or longitude. A sensor might also be used to monitor certain conditions such as on/off or motion/no motions. We call these states.</value>
  </data>
  <data name="WorkflowInput_States" xml:space="preserve">
    <value>States</value>
  </data>
  <data name="WorkflowInput_States_Help" xml:space="preserve">
    <value>If your sensor will provide you changes of conditions that have unique categories, your sensor should likely be be defined as a state based sensor.  You can provide a list of the certain states or a list of conditions that the sensor may report. These might be as simple as On/Off, Motion, No Motion, Position 1, Postiion 2, etc..  For your state configuration you don't need to provide the exact message the sensor will send, the translation value will do that mapping.</value>
  </data>
  <data name="WorkflowInput_Units" xml:space="preserve">
    <value>Units</value>
  </data>
  <data name="WorkflowInput_Units_Help" xml:space="preserve">
    <value>You can optionally provide a unit or set of units to describe the type of data your sensor will receive. This does not apply to state based sensors and is optional. If you don't provide a value it is assumed that the sensor just provides simple numeric data and will be treated as so.</value>
  </data>
  <data name="OutputCommand_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="OutputCommand_Script_Help" xml:space="preserve">
    <value>You need to provide a script that will prepare a payload of data that can be sent to the device.  This payload typically uses data from the attributes of the device.</value>
  </data>
  <data name="Attribute_Type_Discrete_Units" xml:space="preserve">
    <value>Discrete with Units</value>
  </data>
  <data name="Attribute_Type_Discrete_Units_Help" xml:space="preserve">
    <value>You can congifure your attribute to capture a simple numeric value and specify a default type of unit such as RPM, KPH, etc...</value>
  </data>
  <data name="Attribute_States" xml:space="preserve">
    <value>States</value>
  </data>
  <data name="Attribute_States_Help" xml:space="preserve">
    <value>If your attribute is of type State, you will need to provide a list of states that the attribute will support.</value>
  </data>
  <data name="WorkflowInput_SetScript" xml:space="preserve">
    <value>Set Script</value>
  </data>
  <data name="WorkflowInput_SetScript_Help" xml:space="preserve">
    <value>You can either map your sensor directly to an attribute, or you can provide a script that can manipulate the raw values prior them to applying the sensor value to the attribute.  If you provide a script, you can map your sensor input to many different attributes.</value>
  </data>
  <data name="WorkflowInput_Type_Discrete" xml:space="preserve">
    <value>Discrete </value>
  </data>
  <data name="WorkflowInput_Type_Discrete_Help" xml:space="preserve">
    <value>You can configure your input to provide a simple numeric value that does not have any units attached.</value>
  </data>
  <data name="WorkflowInput_Type_Discrete_Units" xml:space="preserve">
    <value>Discrete with Units</value>
  </data>
  <data name="WorkflowInput_Type_Discrete_Units_Help" xml:space="preserve">
    <value>You can congifure your input to provide a simple numeric value and specify a default type of unit such as RPM, KPH, etc...  </value>
  </data>
  <data name="WorkflowInput_Type_State" xml:space="preserve">
    <value>State</value>
  </data>
  <data name="WorkflowInput_Type_State_Help" xml:space="preserve">
    <value>You can configure your input to only map to a certain set of conditions that we call states, these can be things like Open/Closed, Working/Idle/Error.</value>
  </data>
  <data name="Attribute_UnitSet" xml:space="preserve">
    <value>Unit Set</value>
  </data>
  <data name="Attribute_UnitSet_Help" xml:space="preserve">
    <value>If your attribute type is defined as Discrete with Units you must provide the unit set associated with this attribute.</value>
  </data>
  <data name="UnitSet_DefaultUnit" xml:space="preserve">
    <value>Default Unit</value>
  </data>
  <data name="Unit_IsDefault_Help" xml:space="preserve">
    <value>Only one unit can be defined as the default unit.  The values will be stored as this unit and the conversion scripts for the other units will provide conversions. Once a default unit is set, it can not be modified.</value>
  </data>
  <data name="UnitSet_Units" xml:space="preserve">
    <value>Units</value>
  </data>
  <data name="Attribute_Type_Text" xml:space="preserve">
    <value>Text</value>
  </data>
  <data name="Attribute_Type_Text_Help" xml:space="preserve">
    <value>Simple text as attribute type.  </value>
  </data>
  <data name="WorkflowInput_Type_Text_Help" xml:space="preserve">
    <value>Simple text as input.</value>
  </data>
  <data name="WorkflowInput_Type_Text" xml:space="preserve">
    <value>Text</value>
  </data>
  <data name="Unit_Conversion_Type" xml:space="preserve">
    <value>Conversion Type</value>
  </data>
  <data name="Unit_Conversion_Type_Factor" xml:space="preserve">
    <value>Conversion Factor</value>
  </data>
  <data name="Unit_Conversion_Type_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="Unit_Conversion_Factor" xml:space="preserve">
    <value>Conversion Factor</value>
  </data>
  <data name="Unit_Conversion_Factor_Help" xml:space="preserve">
    <value>If converting between this unit and the default unit type is a simple numeric factor that can be applied you don't need to write a script, you can just enter the conversion factor.</value>
  </data>
  <data name="Unit_Conversion_Type_Factor_Help" xml:space="preserve">
    <value>Converting between this unit and the default unit is just applying a numeric constant to the original unit.</value>
  </data>
  <data name="Unit_Conversion_Type_Script_Help" xml:space="preserve">
    <value>Converting between this unit and the default unit requires a more complex formula that requires more than just a constant value.</value>
  </data>
  <data name="Unit_Conversion_Type_Help" xml:space="preserve">
    <value>You can only have one default unit per unit set. That default unit is how the data is stored. Your data however can be displayed and used in different types of units.  You can provide either a factor or formula to convert the default unit value to these different units.</value>
  </data>
  <data name="UnitSet_IsLocked" xml:space="preserve">
    <value>Is Locked</value>
  </data>
  <data name="UnitSet_IsLocked_Help" xml:space="preserve">
    <value>Once you establish your unit set, you may want to lock this so it can't be edited. Since unit sets in many different areas, making changes to an existing unit set may have undesired side effects</value>
  </data>
  <data name="StateSet_Description" xml:space="preserve">
    <value>You have the flexibility to define different statuses that your device may exhibit, known as states. These states can encompass conditions such as On/Off, Running/Idle/Error, Motion/NoMotion, and more.</value>
  </data>
  <data name="StateSet_Help" xml:space="preserve">
    <value>You have the flexibility to define different statuses that your device may exhibit, known as states. These states can encompass conditions such as On/Off, Running/Idle/Error, Motion/NoMotion, and more.</value>
  </data>
  <data name="StateSet_IsLocked" xml:space="preserve">
    <value>Is Locked</value>
  </data>
  <data name="StateSet_IsLocked_Help" xml:space="preserve">
    <value>Once you establish your unit set, you may want to lock this so it can't be edited. Since unit sets in many different areas, making changes to an existing unit set may have undesired side effects</value>
  </data>
  <data name="StateSet_States" xml:space="preserve">
    <value>States</value>
  </data>
  <data name="StateSet_Title" xml:space="preserve">
    <value>State Sets</value>
  </data>
  <data name="EventSet_Description" xml:space="preserve">
    <value>Events are used to trigger actions against a state machine.  An event belongs to an Event Set that can be resused across different state machines to implement custom logic.</value>
  </data>
  <data name="EventSet_Events" xml:space="preserve">
    <value>Events</value>
  </data>
  <data name="EventSet_Help" xml:space="preserve">
    <value>Events are used to trigger actions against a state machine.  An event belongs to an Event Set that can be resused across different state machines to implement custom logic.</value>
  </data>
  <data name="EventSet_IsLocked" xml:space="preserve">
    <value>Is Locked</value>
  </data>
  <data name="EventSet_IsLocked_Help" xml:space="preserve">
    <value>An event set can be locked to prevent users from changing it.  It is a good idea to lock an event set when your device configuration goes into production since changing it may impact existing configurations.</value>
  </data>
  <data name="EventSet_Title" xml:space="preserve">
    <value>Event Set</value>
  </data>
  <data name="Unit_DisplayFormat" xml:space="preserve">
    <value>Display Format</value>
  </data>
  <data name="Unit_DisplayFormat_Help" xml:space="preserve">
    <value>You can create a script that will return a formatted string that will display units properly.</value>
  </data>
  <data name="DeviceConfiguration_Version" xml:space="preserve">
    <value>Version</value>
  </data>
  <data name="Parameter_Help" xml:space="preserve">
    <value>Parameters Can Specify the Data Types that sending and receiving objects expect</value>
  </data>
  <data name="Parameter_Title" xml:space="preserve">
    <value>Parameter</value>
  </data>
  <data name="InputCommandParamter_Description" xml:space="preserve">
    <value>When an input command is exposed from your device configuration, you can pass in parameters along with that command.</value>
  </data>
  <data name="InputCommand_Description" xml:space="preserve">
    <value>Input Commands are used to send messages or commands into your device workflow that usually originate from somewhere other than the actual device itself.  These are exposed as an API in the format of your choosing and can be things like "Reset Device", "Start", "Stop", etc...</value>
  </data>
  <data name="InputCommand_Help" xml:space="preserve">
    <value>Input Commands are used to send messages or commands into your device workflow that usually originate from somewhere other than the actual device itself.  These are exposed as an API in the format of your choosing and can be things like "Reset Device", "Start", "Stop", etc... 

Your input commands will be exposed as a generated API that you can call for this device configuration.</value>
  </data>
  <data name="InputCommand_Parameters" xml:space="preserve">
    <value>Parameters</value>
  </data>
  <data name="InputCommand_Title" xml:space="preserve">
    <value>Input Command</value>
  </data>
  <data name="WorkflowInput_Type_GeoLocation" xml:space="preserve">
    <value>Geolocation</value>
  </data>
  <data name="DeviceWorkflow_Inputs" xml:space="preserve">
    <value>Inputs</value>
  </data>
  <data name="DeviceWorkflow_OutputCommands" xml:space="preserve">
    <value>Output Commands</value>
  </data>
  <data name="WorkflowInput_Type_GeoLocation_Help" xml:space="preserve">
    <value>You can configure your input to accept GeoLocation (Latitude/Longitude) data</value>
  </data>
  <data name="DeviceWorkflow_Description" xml:space="preserve">
    <value>Attributes act as metadata linked to a device workflow, contributing to the preservation of the device's state. These attributes are represented as simple values with an optional unit. Stored on a per-device basis, they are accessible to all workflows associated with the device.</value>
  </data>
  <data name="DeviceWorkflow_Help" xml:space="preserve">
    <value>A Device Workflow is the implemented business logic that relies on inputs from sensors, input commands sent through another application or a user interface, and the current state of the device configuration. It defines how the device should operate and respond based on these inputs and configurations.</value>
  </data>
  <data name="DeviceWorkflow_Title" xml:space="preserve">
    <value>Device Workflow</value>
  </data>
  <data name="StateMachine_State_IsInitialState" xml:space="preserve">
    <value>Is Initial State</value>
  </data>
  <data name="StateMachine_State_IsInitialState_Help" xml:space="preserve">
    <value>Whenever you create a set of states, only one state can be active at any time.  You need to specifiy the default or initial state that will be used to initialize data.</value>
  </data>
  <data name="StateMachine_Transition_Script" xml:space="preserve">
    <value>On Transition Script</value>
  </data>
  <data name="Attribute_Type_GeoLocation" xml:space="preserve">
    <value>Geolocation</value>
  </data>
  <data name="Attribute_Type_GeoLocation_Help" xml:space="preserve">
    <value>Specifies a Lattitude and Longitude</value>
  </data>
  <data name="Parameter_Types_GeoLocation" xml:space="preserve">
    <value>Geolocation</value>
  </data>
  <data name="Parameter_Type_Watermark" xml:space="preserve">
    <value>-select parameter type-</value>
  </data>
  <data name="WorkflowInput_Type_Watermark" xml:space="preserve">
    <value>-select input type-</value>
  </data>
  <data name="ParameterLocation" xml:space="preserve">
    <value>Parameter Location</value>
  </data>
  <data name="ParameterLocation_JSON" xml:space="preserve">
    <value>Body/JSON</value>
  </data>
  <data name="InputCommand_EndpointType" xml:space="preserve">
    <value>End Point Type</value>
  </data>
  <data name="InputCommand_EndpointType_REST_Delete" xml:space="preserve">
    <value>REST - Delete</value>
  </data>
  <data name="InputCommand_EndpointType_REST_Get" xml:space="preserve">
    <value>REST - Get</value>
  </data>
  <data name="InputCommand_EndpointType_REST_Post" xml:space="preserve">
    <value>REST - Post</value>
  </data>
  <data name="InputCommand_EndpointType_REST_Put" xml:space="preserve">
    <value>REST - Put</value>
  </data>
  <data name="InputCommand_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="InputCommand_Script_Help" xml:space="preserve">
    <value>You can enter a script that is execute when you receive an input command, you will have any parameters that were passed to the command available to the script</value>
  </data>
  <data name="ParameterLocation_Help" xml:space="preserve">
    <value>If you need to pass in parameters you can specify how you want those parameters to be sent in your generated API.</value>
  </data>
  <data name="InputCommand_EndpointType_Help" xml:space="preserve">
    <value>You can specify how you want this input command exposed in your generated API.</value>
  </data>
  <data name="ParameterLocation_Watermark" xml:space="preserve">
    <value>-select endpoint payload type-</value>
  </data>
  <data name="InputCommand_EndpointType_Watermark" xml:space="preserve">
    <value>-select endpoint type-</value>
  </data>
  <data name="ParameterLocation_QueryString" xml:space="preserve">
    <value>Query String</value>
  </data>
  <data name="InputCommand_EndpointType_Internal" xml:space="preserve">
    <value>Internal</value>
  </data>
  <data name="InputCommand_EndpointType_Internal_Help" xml:space="preserve">
    <value>This input command will not be exposed as a REST input command, and will only be available via scripting from other internal components.</value>
  </data>
  <data name="Attribute_Script_Watermark" xml:space="preserve">
    <value>Edit On-Set Script</value>
  </data>
  <data name="Attribute_UnitSet_Watermark" xml:space="preserve">
    <value>-select units for attribute-</value>
  </data>
  <data name="Atttribute_StateSet_Watermark" xml:space="preserve">
    <value>-select states for attribute-</value>
  </data>
  <data name="WorkflowInput_Script_Watermark" xml:space="preserve">
    <value>Edit On-Arrival Script</value>
  </data>
  <data name="WorkflowInput_StateSet_Watermark" xml:space="preserve">
    <value>-select states for input-</value>
  </data>
  <data name="WorkflowInput_UnitSet_Watermark" xml:space="preserve">
    <value>-select units for input-</value>
  </data>
  <data name="Unit_Conversion_EditScriptWatermark" xml:space="preserve">
    <value>Add Conversion Script</value>
  </data>
  <data name="Common_ValidationErrors" xml:space="preserve">
    <value>Validation Errors</value>
  </data>
  <data name="Common_IsValid" xml:space="preserve">
    <value>Is Valid</value>
  </data>
  <data name="Attribute_Type_Boolean_Help" xml:space="preserve">
    <value>An attribute that can either be true or false</value>
  </data>
  <data name="Attribute_ReadOnly" xml:space="preserve">
    <value>Read Only</value>
  </data>
  <data name="Attribute_ReadOnly_Help" xml:space="preserve">
    <value>You can specify your attribute to be read only, if you do so it can only be updated explicity by adding a link to the componet that will update it.  If it's not read only you can update it from any script.</value>
  </data>
  <data name="Attribute_Type_Boolean" xml:space="preserve">
    <value>True/False</value>
  </data>
  <data name="WorkflowInput_Type_Boolean" xml:space="preserve">
    <value>True/False</value>
  </data>
  <data name="WorkflowInput_Type_Boolean_Help" xml:space="preserve">
    <value>An input that can either be true or false</value>
  </data>
  <data name="Parameter_Types_DateTime" xml:space="preserve">
    <value>Date Time</value>
  </data>
  <data name="Parameter_Types_States" xml:space="preserve">
    <value>States</value>
  </data>
  <data name="Common_PageNumberOne" xml:space="preserve">
    <value>Page 1</value>
  </data>
  <data name="DeviceWorkflow_Pages" xml:space="preserve">
    <value>Pages</value>
  </data>
  <data name="DeviceWorkflow_Pages_Help" xml:space="preserve">
    <value>Pages are used to organize your device workflow.  You can add elements created on one page to another page, however  each page can only contain one instance of each element.</value>
  </data>
  <data name="StateMachine_Pages" xml:space="preserve">
    <value>Pages</value>
  </data>
  <data name="StateMachine_Pages_Help" xml:space="preserve">
    <value>Pages are used to organize your state machine.  Any states that you add to one page can be added to other pages.  You can now however add the same transition between states on different pages.  Each transition must be unique between states.</value>
  </data>
  <data name="Page_Description" xml:space="preserve">
    <value>Pages are inserted into lists of other objects to organize content and data.  Since the work space for visually configuring objects is limited it can be broken up between pages.</value>
  </data>
  <data name="Page_Help" xml:space="preserve">
    <value>Pages are used to organize content</value>
  </data>
  <data name="Page_Name" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="Page_PageNumber" xml:space="preserve">
    <value>Page Number</value>
  </data>
  <data name="Page_Title" xml:space="preserve">
    <value>Page</value>
  </data>
  <data name="Parameter_Types_ValueWithUnit" xml:space="preserve">
    <value>Value with Units</value>
  </data>
  <data name="DeviceWorkflow_Timer" xml:space="preserve">
    <value>Timer</value>
  </data>
  <data name="Timer_DailyEndTime" xml:space="preserve">
    <value>Daily End Time</value>
  </data>
  <data name="Timer_DailyEndTime_Help" xml:space="preserve">
    <value>The time at which this timer will not execute each day</value>
  </data>
  <data name="Timer_DailyStartTime" xml:space="preserve">
    <value>Daily Start Time</value>
  </data>
  <data name="Timer_DailyStartTime_Help" xml:space="preserve">
    <value>The time at which this timer will start each day</value>
  </data>
  <data name="Timer_Days" xml:space="preserve">
    <value>Days</value>
  </data>
  <data name="Timer_Description" xml:space="preserve">
    <value>Timers can be used to exeute scripts at fixed intervals</value>
  </data>
  <data name="Timer_Friday" xml:space="preserve">
    <value>Friday</value>
  </data>
  <data name="Timer_Help" xml:space="preserve">
    <value>Timers can be used to exeute scripts at fixed intervals</value>
  </data>
  <data name="Timer_HourOfDay" xml:space="preserve">
    <value>Hour of Day</value>
  </data>
  <data name="Timer_Hours" xml:space="preserve">
    <value>Hours</value>
  </data>
  <data name="Timer_MinuteOfDay" xml:space="preserve">
    <value>Minute of Day</value>
  </data>
  <data name="Timer_Minutes" xml:space="preserve">
    <value>Minutes</value>
  </data>
  <data name="Timer_Monday" xml:space="preserve">
    <value>Monday</value>
  </data>
  <data name="Timer_Saturday" xml:space="preserve">
    <value>Saturday</value>
  </data>
  <data name="Timer_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="Timer_Seconds" xml:space="preserve">
    <value>Seconds</value>
  </data>
  <data name="Timer_Sunday" xml:space="preserve">
    <value>Sunday</value>
  </data>
  <data name="Timer_Thursday" xml:space="preserve">
    <value>Thursday</value>
  </data>
  <data name="Timer_Title" xml:space="preserve">
    <value>Timer</value>
  </data>
  <data name="Timer_Tuesday" xml:space="preserve">
    <value>Tuesday</value>
  </data>
  <data name="Timer_Wednesday" xml:space="preserve">
    <value>Wednesday</value>
  </data>
  <data name="DeviceType_Description" xml:space="preserve">
    <value>The Device Model serves to uniquely identify a particular make and model of a device. It comes with an associated Device Configuration, which outlines the instructions on how messages from this specific device should be processed.</value>
  </data>
  <data name="DeviceType_Help" xml:space="preserve">
    <value>The Device Model serves to uniquely identify a particular make and model of a device. It comes with an associated Device Configuration, which outlines the instructions on how messages from this specific device should be processed.</value>
  </data>
  <data name="DeviceType_Title" xml:space="preserve">
    <value>Device Model</value>
  </data>
  <data name="DeviceType_DefaultConfiguration" xml:space="preserve">
    <value>Default Device Configuration</value>
  </data>
  <data name="DeviceType_DefaultConfiguration_Help" xml:space="preserve">
    <value>The Device Configuration will determine how messages from your device are handled.  You can specify a default device configuration for this device type.</value>
  </data>
  <data name="DeviceType_DefaultConfiguration_Select" xml:space="preserve">
    <value>-select default configuration-</value>
  </data>
  <data name="CusotmField_HelpText_Help" xml:space="preserve">
    <value>You can add a help message that will be displayed when the user is editing the device.</value>
  </data>
  <data name="CustomField_HelpText" xml:space="preserve">
    <value>Help Text</value>
  </data>
  <data name="CustomField_IsReadOnly" xml:space="preserve">
    <value>Is Read Only</value>
  </data>
  <data name="CustomField_IsReadOnly_Help" xml:space="preserve">
    <value>If you set this custom field to be read only, the field will only be editable when provisioning the device.</value>
  </data>
  <data name="StateMachine_RequireEnum" xml:space="preserve">
    <value>Require Integer Enums</value>
  </data>
  <data name="StateMachine_RequireEnum_Help" xml:space="preserve">
    <value>When entering your states each state is required to contain a unique integer value that will act as a numeric enumeration value for mapping external values.</value>
  </data>
  <data name="StateMachine_State_Enum" xml:space="preserve">
    <value>Enum Value</value>
  </data>
  <data name="StateMachine_State_Enum_Help" xml:space="preserve">
    <value>In addition to providing a user provided key value that can be used to uniquely identify your state, you can also provide an integer value that can be used to map to external numeric values in a message or some other source.  </value>
  </data>
  <data name="Unit_ConversionFrom_Script" xml:space="preserve">
    <value>Script - Convert from this Unit to Default Unit</value>
  </data>
  <data name="Unit_ConversionFrom_Script_Help" xml:space="preserve">
    <value>Provide a script that will take a value in this unit and convert it to a value of the unit that is specified as the default unit.</value>
  </data>
  <data name="Unit_NumberDecimal_Help" xml:space="preserve">
    <value>Specify the number of decimal points to store and display this value.</value>
  </data>
  <data name="Err_CouldNotLoadDeviceWorkflow" xml:space="preserve">
    <value>Could Not Load Device Workflow</value>
  </data>
  <data name="Err_CouldNotLoadStateSet" xml:space="preserve">
    <value>Could Not Load State Set</value>
  </data>
  <data name="Err_CouldNotLoadUnitSet" xml:space="preserve">
    <value>Could Not Load Unit Set</value>
  </data>
  <data name="Attribute_DefaultValue" xml:space="preserve">
    <value>Default Value</value>
  </data>
  <data name="CustomField_FieldType_Watermark" xml:space="preserve">
    <value>-field type-</value>
  </data>
  <data name="CustomField_Label_Help" xml:space="preserve">
    <value>Provide a label that will serve as a caption for the custom field.</value>
  </data>
  <data name="CustomField_StateSet" xml:space="preserve">
    <value>State Set</value>
  </data>
  <data name="CustomField_UnitSet" xml:space="preserve">
    <value>Unit Set</value>
  </data>
  <data name="CustomField_StateSet_Select" xml:space="preserve">
    <value>-select state set-</value>
  </data>
  <data name="CustomField_UnitSet_Select" xml:space="preserve">
    <value>-select units-</value>
  </data>
  <data name="StateMachine_State_Key_RegEx" xml:space="preserve">
    <value>Keys for states must be a minimum of 2 character and a maximum of 20 characters, they may only contain lowercase letters and numbers.</value>
  </data>
  <data name="DeviceWorkflow_Settings" xml:space="preserve">
    <value>Settings</value>
  </data>
  <data name="DeviceWorkflow_Settings_Help" xml:space="preserve">
    <value>Settings are used to create values that can be configured within your application and used within your scripts.</value>
  </data>
  <data name="DeviceWorkflow_PosthandlerScript" xml:space="preserve">
    <value>Post-Handler Script</value>
  </data>
  <data name="DeviceWorkflow_PosthandlerScript_Help" xml:space="preserve">
    <value>Add a script that will be executed after all the inputs have been set and the device has been updated.</value>
  </data>
  <data name="DeviceWorkflow_PosthandlerScript_Watermark" xml:space="preserve">
    <value>-add posthandler script-</value>
  </data>
  <data name="DeviceWorkflow_PrehandlerScript" xml:space="preserve">
    <value>Pre-Handler Script</value>
  </data>
  <data name="DeviceWorkflow_PrehandlerScript_Help" xml:space="preserve">
    <value>Add a script that will be executed prior to any inputs being set</value>
  </data>
  <data name="DeviceWorkflow_PrehandlerScript_Watermark" xml:space="preserve">
    <value>-add prehandler script-</value>
  </data>
  <data name="CustomField_MaxValue" xml:space="preserve">
    <value>Max Value</value>
  </data>
  <data name="CustomField_MinValue" xml:space="preserve">
    <value>Min Value</value>
  </data>
  <data name="Parameter_DefaultValue" xml:space="preserve">
    <value>Default Value</value>
  </data>
  <data name="Parameter_MaximumValue" xml:space="preserve">
    <value>Maximum Value</value>
  </data>
  <data name="Parameter_MinimumValue" xml:space="preserve">
    <value>Minimum Value</value>
  </data>
  <data name="Parameter_Types_Image" xml:space="preserve">
    <value>Image</value>
  </data>
  <data name="State_IsAlarmState" xml:space="preserve">
    <value>Is Alarm State</value>
  </data>
  <data name="State_IsAlarmState_Help" xml:space="preserve">
    <value>If you set this state as an alarm, when the device is in this state, the device will have an alarm associated with it that will be visible when users view this device.</value>
  </data>
  <data name="DeviceBOMItem_AssemblyNumber" xml:space="preserve">
    <value>Assembly Number</value>
  </data>
  <data name="DeviceBOMItem_Description" xml:space="preserve">
    <value>A bill of material item contains a part that makes up the device</value>
  </data>
  <data name="DeviceBOMItem_Help" xml:space="preserve">
    <value>A bill of material item contains a part that makes up the device</value>
  </data>
  <data name="DeviceBOMItem_Link" xml:space="preserve">
    <value>Link</value>
  </data>
  <data name="DeviceBOMItem_Manufacturer" xml:space="preserve">
    <value>Manufacturer</value>
  </data>
  <data name="DeviceBOMItem_PartNumber" xml:space="preserve">
    <value>Part Number</value>
  </data>
  <data name="DeviceBOMItem_Picture" xml:space="preserve">
    <value>Picture</value>
  </data>
  <data name="DeviceBOMItem_Quantity" xml:space="preserve">
    <value>Quantity</value>
  </data>
  <data name="DeviceBOMItem_Title" xml:space="preserve">
    <value>Device Bill of Material Item</value>
  </data>
  <data name="DeviceResources_Description" xml:space="preserve">
    <value>A device resource is a file that can either be uploaded or linked to an external site to help provide information about a specific device.</value>
  </data>
  <data name="DeviceResources_FileName" xml:space="preserve">
    <value>File Name</value>
  </data>
  <data name="DeviceResources_Help" xml:space="preserve">
    <value>A device resource is a file that can either be uploaded or linked to an external site to help provide information about a specific device.</value>
  </data>
  <data name="DeviceResources_MimeType" xml:space="preserve">
    <value>MimeType</value>
  </data>
  <data name="DeviceResources_ResourceType" xml:space="preserve">
    <value>Resource Type</value>
  </data>
  <data name="DeviceResources_Title" xml:space="preserve">
    <value>Device Resources</value>
  </data>
  <data name="DeviceResourceTypes_Manual" xml:space="preserve">
    <value>Manual</value>
  </data>
  <data name="DeviceResourceTypes_Other" xml:space="preserve">
    <value>Other</value>
  </data>
  <data name="DeviceResourceTypes_PartsList" xml:space="preserve">
    <value>Parts List</value>
  </data>
  <data name="DeviceResourceTypes_Picture" xml:space="preserve">
    <value>Picture</value>
  </data>
  <data name="DeviceResourceTypes_Specification" xml:space="preserve">
    <value>Specification</value>
  </data>
  <data name="DeviceResourceTypes_UserGuide" xml:space="preserve">
    <value>User Guide</value>
  </data>
  <data name="DeviceResourceTypes_Video" xml:space="preserve">
    <value>Video</value>
  </data>
  <data name="DeviceType_BillOfMaterial" xml:space="preserve">
    <value>Bill of Material</value>
  </data>
  <data name="DeviceType_Resources" xml:space="preserve">
    <value>Resources</value>
  </data>
  <data name="DeviceResource_ContentLength" xml:space="preserve">
    <value>Content Length</value>
  </data>
  <data name="DeviceResource_SelectType" xml:space="preserve">
    <value>-select resource type-</value>
  </data>
  <data name="DeviceResource_IsFileUpload" xml:space="preserve">
    <value>Is File Upload</value>
  </data>
  <data name="DeviceResource_Link" xml:space="preserve">
    <value>Web Link</value>
  </data>
  <data name="DeviceResource_Link_Help" xml:space="preserve">
    <value>Provide a link to an external resource.</value>
  </data>
  <data name="Common_Resources" xml:space="preserve">
    <value>Resources</value>
  </data>
  <data name="Equipment_Description" xml:space="preserve">
    <value>Equipment are tools and other components that are related to the device type.</value>
  </data>
  <data name="Equipment_Help" xml:space="preserve">
    <value>Equipment are tools and other components that are related to the device type.</value>
  </data>
  <data name="Equipment_Title" xml:space="preserve">
    <value>Equipment</value>
  </data>
  <data name="DeviceType_AssociatedTools" xml:space="preserve">
    <value>Associated Tools</value>
  </data>
  <data name="DeviceWorkflow_ServiceTicketTemplates" xml:space="preserve">
    <value>Service Ticket Templates</value>
  </data>
  <data name="DeviceBOMItem_IsPartsKit" xml:space="preserve">
    <value>Is Parts Kit</value>
  </data>
  <data name="Part_Description" xml:space="preserve">
    <value>A part is the smallest component that can be tracked or an individual part that could make up an assembly</value>
  </data>
  <data name="Part_Help" xml:space="preserve">
    <value>A part is the smallest component that can be tracked or an individual part that could make up an assembly</value>
  </data>
  <data name="Part_Manufacturer" xml:space="preserve">
    <value>Manufacturer</value>
  </data>
  <data name="Part_PartNumber" xml:space="preserve">
    <value>Part Number</value>
  </data>
  <data name="Part_SKU" xml:space="preserve">
    <value>SKU</value>
  </data>
  <data name="Part_Title" xml:space="preserve">
    <value>Part</value>
  </data>
  <data name="Custom_PropertyId" xml:space="preserve">
    <value>Property Id</value>
  </data>
  <data name="Custom_PropertyId_Help" xml:space="preserve">
    <value>You can optionally add a property id that can be syncronized with values in your remote device.</value>
  </data>
  <data name="Custom_RemoteProperty" xml:space="preserve">
    <value>Remote Property</value>
  </data>
  <data name="Custom_RemoteProperty_Help" xml:space="preserve">
    <value>A remote property is one that will be kept in sync with properties made available on the device.</value>
  </data>
  <data name="DeviceType_Firmware" xml:space="preserve">
    <value>Firmware</value>
  </data>
  <data name="DeviceType_FirmwareSelect" xml:space="preserve">
    <value>-select firmware-</value>
  </data>
  <data name="CustomFIeld_IsUserConfigurable" xml:space="preserve">
    <value>Is User Configurable</value>
  </data>
  <data name="CustomFIeld_IsUserConfigurable_Help" xml:space="preserve">
    <value>If you specify your field as a user configurable field, any user that can modify the device can edit the property.  If you don't select this option, only an admin can update the field.</value>
  </data>
  <data name="BusinessRule_Description" xml:space="preserve">
    <value>Business rules are concise scripts created to be executed based on attributes and properties, evaluating the proper functioning of a device. Moreover, these rules can generate service tickets and error codes when necessary. It's important to note that business rules are evaluated after all the scripts in the workflow have been executed.</value>
  </data>
  <data name="BusinessRule_ErrorCode" xml:space="preserve">
    <value>Error Code</value>
  </data>
  <data name="BusinessRule_ErrorCode_Help" xml:space="preserve">
    <value>If the script returns false, the error code will be generated for the device if it's enabled or if Is Beta is selected and it's a beta device.</value>
  </data>
  <data name="BusinessRule_ErrorCode_Watermark" xml:space="preserve">
    <value>-select error code-</value>
  </data>
  <data name="BusinessRule_Help" xml:space="preserve">
    <value>Business rules are concise scripts created to be executed based on attributes and properties, evaluating the proper functioning of a device. Moreover, these rules can generate service tickets and error codes when necessary. It's important to note that business rules are evaluated after all the scripts in the workflow have been executed.</value>
  </data>
  <data name="BusinessRule_IsBeta" xml:space="preserve">
    <value>Is Beta</value>
  </data>
  <data name="BusinessRule_IsBeta_Help" xml:space="preserve">
    <value>When Is Beta is selected only devices that have been marked as "Beta Devices" will execute this business rule.</value>
  </data>
  <data name="BusinessRule_IsEnabled" xml:space="preserve">
    <value>Is Enabled</value>
  </data>
  <data name="BusinessRule_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="BusinessRule_Script_Help" xml:space="preserve">
    <value>Script to be executed for this business rule.  It will be executed upon completion of all the other scripts on this workflow.  The script must return true if the business rule succeeds, and false if there is an error condition.  If there is an error condition any error codes or service tickets will be generated.</value>
  </data>
  <data name="BusinessRule_Script_Watermark" xml:space="preserve">
    <value>-business rule script-</value>
  </data>
  <data name="BusinessRule_ServiceTicket" xml:space="preserve">
    <value>Service Ticket Template</value>
  </data>
  <data name="BusinessRule_ServiceTicket_Help" xml:space="preserve">
    <value>If the script returns false, the service ticket  will be generated for the device if it's enabled or if Is Beta is selected and it's a beta device.</value>
  </data>
  <data name="BusinessRule_ServiceTicket_Watermark" xml:space="preserve">
    <value>-select service ticket template-</value>
  </data>
  <data name="BusinessRule_Title" xml:space="preserve">
    <value>Device Business Rule</value>
  </data>
  <data name="DeviceWorkflow_BusinessRules" xml:space="preserve">
    <value>Business Rules</value>
  </data>
  <data name="DeviceWorkflow_BusinessRules_Help" xml:space="preserve">
    <value>Business rules are small scripts designed to be executed based on attributes and properties to assess the proper functioning of a device. Additionally, these rules can generate service tickets and error codes when necessar</value>
  </data>
  <data name="Parameter_Types_DecimalArray" xml:space="preserve">
    <value>Decimal Array</value>
  </data>
  <data name="Parameter_Types_MLInference" xml:space="preserve">
    <value>ML Inference</value>
  </data>
  <data name="Parameter_Types_Object" xml:space="preserve">
    <value>Object</value>
  </data>
  <data name="Parameter_Types_IntArray" xml:space="preserve">
    <value>Integer Array</value>
  </data>
  <data name="Parameter_Types_StringArray" xml:space="preserve">
    <value>String Array</value>
  </data>
  <data name="DeviceType_Firmware_Revision" xml:space="preserve">
    <value>Firmware Revision</value>
  </data>
  <data name="DeviceType_Firmware_RevisionSelect" xml:space="preserve">
    <value>-select firmware revision-</value>
  </data>
  <data name="InputCommand_ScriptWatermark" xml:space="preserve">
    <value>On Arrive Script</value>
  </data>
  <data name="OutputCommand_Script_WaterMark" xml:space="preserve">
    <value>On Execute Script</value>
  </data>
  <data name="State_ErrorCode" xml:space="preserve">
    <value>Error Code</value>
  </data>
  <data name="State_ErrorCode_Help" xml:space="preserve">
    <value>Device or State Machine will generate an Error Code to be handled when transitioned into this state.</value>
  </data>
  <data name="State_ErrorCode_Select" xml:space="preserve">
    <value>-select error code-</value>
  </data>
  <data name="State_TransitionInAction_Watermark" xml:space="preserve">
    <value>Add Transition In Action Script</value>
  </data>
  <data name="Unit_SelectConversionType_Watermark" xml:space="preserve">
    <value>-select conversion type-</value>
  </data>
  <data name="DeviceType_Icon" xml:space="preserve">
    <value>Device Model Icon</value>
  </data>
  <data name="DeviceTypes_Title" xml:space="preserve">
    <value>Device Models</value>
  </data>
  <data name="DeviceWorkflows_Title" xml:space="preserve">
    <value>Device Workflows</value>
  </data>
  <data name="StateMachine_Transition_Script_Watermark" xml:space="preserve">
    <value>Add Transition Action</value>
  </data>
  <data name="OutputCommand_Parameters" xml:space="preserve">
    <value>Parameters</value>
  </data>
  <data name="OutputCommand_Parameters_Help" xml:space="preserve">
    <value>The Parameters on the Output Command consist of data that can be formatted using a Device Message Definition so that it can be sent back to the device or other system.</value>
  </data>
  <data name="Common_Icon" xml:space="preserve">
    <value>Icon</value>
  </data>
  <data name="Common_Category" xml:space="preserve">
    <value>Category</value>
  </data>
  <data name="Common_SelectCategory" xml:space="preserve">
    <value>-select category-</value>
  </data>
  <data name="DeviceBOMItem_Cost" xml:space="preserve">
    <value>Cost</value>
  </data>
  <data name="DeviceType_Product" xml:space="preserve">
    <value>Product</value>
  </data>
  <data name="DeviceType_Product_Select" xml:space="preserve">
    <value>-select product-</value>
  </data>
  <data name="CompomentPurcahse_Title" xml:space="preserve">
    <value>Component Purchase</value>
  </data>
  <data name="PartType_ThroughHole" xml:space="preserve">
    <value>Through Hole</value>
  </data>
  <data name="PartType_SurfaceMount" xml:space="preserve">
    <value>Surface Mount</value>
  </data>
  <data name="PartType_Hardware" xml:space="preserve">
    <value>Hardware</value>
  </data>
  <data name="Feeders_Title" xml:space="preserve">
    <value>Feeders</value>
  </data>
  <data name="Feeder_Description" xml:space="preserve">
    <value>A feeder is a device that provides parts for a pick and place machine.</value>
  </data>
  <data name="Feeder_Title" xml:space="preserve">
    <value>Feeder</value>
  </data>
  <data name="PartPacks_Title" xml:space="preserve">
    <value>Part Packs</value>
  </data>
  <data name="PartPack_Description" xml:space="preserve">
    <value>Part Packs are strip feeders with identified parts on board.</value>
  </data>
  <data name="PartPack_Title" xml:space="preserve">
    <value>Part Pack</value>
  </data>
  <data name="PickAndPlaceJob_Title" xml:space="preserve">
    <value>Pick and Place Job</value>
  </data>
  <data name="PackAndPlace_Description" xml:space="preserve">
    <value>A Pick and Place job has the parameters for a job that should be run on a pick and place machine</value>
  </data>
</root>